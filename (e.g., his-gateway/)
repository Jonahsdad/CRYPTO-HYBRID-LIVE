import os, time, json
from typing import Dict, Any
from fastapi import FastAPI, HTTPException, Query
import httpx

APP_NAME = "HIS Data Gateway"
TIMEOUT = float(os.getenv("TIMEOUT", "25"))

COINGECKO   = "https://api.coingecko.com/api/v3"
COINPAPRIKA = "https://api.coinpaprika.com/v1"
PUSHSHIFT   = "https://api.pushshift.io/reddit/search/submission/"
YF_CHART    = "https://query1.finance.yahoo.com/v8/finance/chart/{sym}"

ODDS_API_KEY = os.getenv("ODDS_API_KEY", "")     # the-odds-api.com
FRED_API_KEY = os.getenv("FRED_API_KEY", "")     # fred.stlouisfed.org
EIA_API_KEY  = os.getenv("EIA_API_KEY", "")      # api.eia.gov

app = FastAPI(title=APP_NAME)

# --------------------------- tiny in-memory cache ------------------------------
_cache: Dict[str, Dict[str, Any]] = {}  # key -> {"t": epoch, "data": any}

def _ck(path: str, params: Dict[str, Any]) -> str:
    return path + "?" + "&".join(f"{k}={v}" for k, v in sorted(params.items()))

def cache_get(path: str, params: Dict[str, Any], ttl: int):
    k = _ck(path, params)
    rec = _cache.get(k)
    if rec and (time.time() - rec["t"]) < ttl:
        return rec["data"]
    return None

def cache_put(path: str, params: Dict[str, Any], data: Any):
    k = _ck(path, params)
    _cache[k] = {"t": time.time(), "data": data}

async def http_get(url: str, params=None, headers=None):
    async with httpx.AsyncClient(timeout=TIMEOUT) as cli:
        r = await cli.get(url, params=params, headers=headers)
        if r.status_code >= 400:
            raise HTTPException(r.status_code, r.text)
        try:
            return r.json()
        except Exception:
            return json.loads(r.text)

def now_ms() -> int: return int(time.time()*1000)

# -------------------------------- endpoints -----------------------------------
@app.get("/health")
async def health():
    return {"ok": True, "ts": now_ms()}

# ---- Crypto quotes (CoinGecko with CoinPaprika fallback) ---------------------
@app.get("/v1/crypto/quotes")
async def crypto_quotes(ids: str = Query(..., description="comma list e.g. bitcoin,ethereum")):
    params = {"ids": ids}
    c = cache_get("/v1/crypto/quotes", params, ttl=30)
    if c: return c
    try:
        data = await http_get(f"{COINGECKO}/coins/markets", params={"vs_currency":"usd","ids":ids})
        out = {
            "provider": "coingecko", "fetched_ms": now_ms(),
            "symbols": [
                {"id":x["id"], "symbol":x["symbol"], "price":x["current_price"],
                 "mc":x.get("market_cap"), "pct_24h":x.get("price_change_percentage_24h")}
                for x in data
            ],
        }
        cache_put("/v1/crypto/quotes", params, out); return out
    except HTTPException:
        data = await http_get(f"{COINPAPRIKA}/tickers")
        want = {s.strip().lower() for s in ids.split(",")}
        filt = [x for x in data if x["name"].lower() in want or x["symbol"].lower() in want]
        out = {
            "provider":"coinpaprika","fetched_ms":now_ms(),
            "symbols":[
                {"id":x["id"],"symbol":x["symbol"],
                 "price":x["quotes"]["USD"]["price"],
                 "mc":x["quotes"]["USD"].get("market_cap"),
                 "pct_24h":x["quotes"]["USD"].get("percent_change_24h")}
                for x in filt
            ]
        }
        cache_put("/v1/crypto/quotes", params, out); return out

# ---- Stocks history (Yahoo chart JSON; no API key required) ------------------
@app.get("/v1/stocks/history")
async def stocks_history(symbol: str, period: str="6mo", interval: str="1d"):
    key = {"s":symbol,"p":period,"i":interval}
    c = cache_get("/v1/stocks/history", key, ttl=120)
    if c: return c
    data = await http_get(YF_CHART.format(sym=symbol),
                          params={"range": period, "interval": interval, "includePrePost":"false"})
    try:
        result = data["chart"]["result"][0]
        ts = result["timestamp"]
        close = result["indicators"]["quote"][0]["close"]
        out = {"provider":"yahoo","fetched_ms":now_ms(),
               "bars":[{"date":int(t)*1000,"close":c} for t,c in zip(ts, close) if c is not None]}
        cache_put("/v1/stocks/history", key, out); return out
    except Exception as e:
        raise HTTPException(502, f"YF parse failed: {e}")

# ---- Sports odds (TheOddsAPI or demo if no key) ------------------------------
@app.get("/v1/sports/odds")
async def sports_odds(sport: str="americanfootball_nfl", market: str="spreads", region: str="us"):
    if not ODDS_API_KEY:
        return {"provider":"demo","fetched_ms":now_ms(),
                "lines":[
                    {"team":"Hawks","moneyline":-120},
                    {"team":"Sharks","moneyline":140},
                    {"team":"Tigers","moneyline":-105},
                    {"team":"Giants","moneyline":155}
                ]}
    url = "https://api.the-odds-api.com/v4/sports/{sport}/odds".format(sport=sport)
    params = {"regions": region, "markets": market, "oddsFormat":"american", "apiKey": ODDS_API_KEY}
    data = await http_get(url, params=params)
    return {"provider":"the-odds-api","fetched_ms":now_ms(),"raw":data}

# ---- Human Behavior (Reddit via Pushshift to avoid 403) ----------------------
@app.get("/v1/social/reddit")
async def reddit_search(q: str="crypto", size: int=10):
    params = {"q": q, "size": size, "sort":"desc"}
    c = cache_get("/v1/social/reddit", params, ttl=60)
    if c: return c
    data = await http_get(PUSHSHIFT, params=params)
    out = {"provider":"pushshift","fetched_ms":now_ms(),
           "posts":[{"title":i.get("title"),"sub":i.get("subreddit"),"score":i.get("score")}
                    for i in data.get("data",[])]}
    cache_put("/v1/social/reddit", params, out); return out

# ---- Lottery (NY Take 5 + IL Pick-4; open data fallbacks) --------------------
@app.get("/v1/lottery/ny_take5_latest")
async def ny_take5_latest():
    url = "https://data.cityofnewyork.us/resource/5xaw-6ayf.json?$limit=1&$order=draw_date DESC"
    data = await http_get(url)
    if not data: raise HTTPException(502, "NY empty")
    row = data[0]
    return {"provider":"nyc_open_data","fetched_ms":now_ms(),
            "draw":row.get("winning_numbers"),"date":row.get("draw_date")}

@app.get("/v1/lottery/il_pick4_latest")
async def il_pick4_latest():
    # IL open-data example dataset (structure can change; we try best-effort parse)
    url = "https://data.illinois.gov/api/views/ck5f-mz5z/rows.json?accessType=DOWNLOAD"
    data = await http_get(url)
    try:
        last = data["data"][-1]
        draw = next((c for c in last if isinstance(c,str) and "-" in c and " " not in c), None)
        date = last[8] if len(last) > 8 else ""
        return {"provider":"illinois_open_data","fetched_ms":now_ms(),"draw":draw,"date":date}
    except Exception as e:
        raise HTTPException(502, f"IL parse failed: {e}")

# ---- Macro / Real Estate proxies (FRED + EIA) --------------------------------
@app.get("/v1/macro/fred")
async def fred_series(series_id: str="MORTGAGE30US"):
    if not FRED_API_KEY:
        return {"provider":"fred-demo","fetched_ms":now_ms(),"series":[]}
    url = "https://api.stlouisfed.org/fred/series/observations"
    data = await http_get(url, params={"series_id":series_id,"api_key":FRED_API_KEY,"file_type":"json"})
    obs = data.get("observations", [])
    return {"provider":"fred","fetched_ms":now_ms(),"series":[{"date":o["date"],"value":o["value"]} for o in obs]}

@app.get("/v1/energy/eia")
async def eia_series(series_id: str="PET.RWTC.D"):
    if not EIA_API_KEY:
        return {"provider":"eia-demo","fetched_ms":now_ms(),"series":[]}
    url = "https://api.eia.gov/series/"
    data = await http_get(url, params={"api_key":EIA_API_KEY,"series_id":series_id})
    s = data.get("series",[{}])[0].get("data",[])
    return {"provider":"eia","fetched_ms":now_ms(),"series":[{"date":d[0],"value":d[1]} for d in s]}
